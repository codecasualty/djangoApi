from django.urls import path, include
from profiles_api import views


from rest_framework.routers import DefaultRouter

router = DefaultRouter()
router.register('hello-viewset' , views.HelloViewSet ,base_name = 'hello-viewset')

# this will convert helloapiview to view, and if get request is made then  get() will be called in HelloApiView
urlpatterns = [
    path('hello-view/', views.HelloApiView.as_view()),
    path('' , include(router.urls))
]

"""
In Django REST Framework (DRF), `views` is typically a module (`views.py`) where your view logic is defined. It contains the classes

or functions that handle the requests and responses for your web application. Here's a breakdown of your questions:

### What is `views` here?

In the context of your example, `views` refers to the Python module where your `HelloViewSet` and any other views or viewsets are defined.

When you import `views` in your `urls.py` file, you're bringing these view definitions into scope so they can be referenced by the URL routing system.

### Why is it included in the file?

`views` is included in the `urls.py` file to connect the URLs to the appropriate viewsets or views. When a specific URL is requested,

Django will use this mapping to determine which view to execute.

### What is `'hello-viewset'` and `base_name='hello-viewset'`?

- `'hello-viewset'`: This is the route or endpoint that will be appended to your base URL to form the complete URL path that will be

exposed for the viewset. For example, if your base URL is `http://127.0.0.1:8000/`, then the `HelloViewSet` will be accessible at `http://127.0.0.1:8000/hello-viewset/`.

- `base_name='hello-viewset'`: This is used by the router to create the names for the URL patterns associated with the viewset. It is

necessary when the viewset does not include a queryset or when you want to override the default naming convention. This base name is used to
 generate names for the individual routes, which can be used in reverse URL lookups.

### What is `DefaultRouter()`?

`DefaultRouter` is a class provided by DRF that automatically creates routes for standard operations provided by viewsets. It extends

the functionality of `SimpleRouter` but also adds a default API root view that lists all routes available in the API. This router handles
routing to the appropriate actions in the viewset based on the HTTP method used (GET, POST, etc.).

### What is `register()`?

`register()` is a method of the router instance where you specify:
- The URL route as a string.
- The viewset class that handles requests for that route.
- An optional `base_name` that is used to refer to the viewset in URL reversing.

### Use Cases

Here's a simple example:

```python
# views.py
from rest_framework import viewsets

class ExampleViewSet(viewsets.ViewSet):
    def list(self, request):
        return Response({"message": "GET request to list items"})

    def create(self, request):
        return Response({"message": "POST request to create an item"})

# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'example', views.ExampleViewSet, base_name='example')

urlpatterns = [
    path('', include(router.urls)),
]
```

In this example:
- An `ExampleViewSet` is defined with methods for listing and creating items.
- A `DefaultRouter` instance is created, and the `ExampleViewSet` is registered under the route `example`.
- The `urlpatterns` list includes the routes generated by the router, effectively exposing the `ExampleViewSet` under the base path `/example/`.

This setup allows for clean and organized URL management in Django, especially useful for larger applications where maintaining

individual URLs for numerous API endpoints could become cumbersome.


In Django REST Framework, the `base_name` parameter in the router's `register()` method is used to specify the base part of the URL
names that will be dynamically generated by the router. This is particularly important and useful in several scenarios:

### Purpose of `base_name`

1. **Naming URL Patterns**: The `base_name` is used to generate the names for the URL patterns associated with a viewset.
This is critical for using Django's `reverse()` function to dynamically generate URLs in your application. For instance, if you have
a `base_name` of `example`, the URL names might be generated as `example-list`, `example-detail`, etc.

2. **When a ViewSet Lacks a `queryset` Attribute**: Normally, if a viewset has a `queryset` attribute,
the router can automatically generate a base name using the model associated with the queryset. However, if the viewset does not
include a `queryset` attribute (which can be common when actions donâ€™t directly relate to a single Django model), you must provide a `base_name`
so that the router can still generate the appropriate URL pattern names.

3. **Overriding Default Names**: If you want to override the automatically generated names for some reason, perhaps to avoid name
clashes or to better describe the resources, `base_name` gives you that flexibility. It allows you to explicitly set the prefix for
the URL names, making them more predictable or semantically meaningful.

### Example of Usage

Here's an example that clarifies the use of `base_name`:

```python
from rest_framework.routers import DefaultRouter
from .views import ExampleViewSet

router = DefaultRouter()
router.register(r'items', ExampleViewSet, base_name='custom-item')

urlpatterns = router.urls
```

In this setup:
- We register a `ExampleViewSet` under the path `items`.
- We specify a `base_name` of `custom-item`.

The router will generate URL names such as:
- `custom-item-list` for the listing route.
- `custom-item-detail` for detail routes.

This means you can use `reverse('custom-item-list')` to dynamically generate the URL to the list route of your viewset, even if
 your viewset does not have a `queryset` attribute, or you want to override the automatic naming.

### Conclusion

Using `base_name` is an essential part of setting up viewsets with routers when you need explicit control over URL pattern names,
especially in larger or more complex Django projects where avoiding name collisions and ensuring clarity in URL configuration is crucial.



"""
